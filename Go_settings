import copy #pour les deepcopies
import marshal #pour les sauvegardes locales
class settings : ###création de la classe settings pour l'attribution des variables utiles pour l'IA. Les autres variables qui ne servent qu'au joueur, le côté du joueur et le handicap, sont saisies au début de Go_main.py###
    def __init__(self,N) :
        self.N=N #taille du goban
        P=[[0 for i in range(N)] for j in range(N)]
        self.P=P #matrice d'état du plateau : 0 pour vide, 1 pour noir, 2 pour blanc
        self.Pos=[copy.deepcopy(P)] #liste des positions P déja atteintes (pour la règle du ko)
        self.Chaines={} #les chaînes formées. Chaines est construite de cette manière (IMPORTANT) : c'est un dictionnaire qui à chaque case (i,j) du plateau associe [[libertés de la chaîne], case_1_de_la_chaîne, ..., dernière_case_de_la_chaîne]. Par exemple, pour une chaîne de 2 cases avec (1,1) et (1,2), Chaîne={(1, 1): [[(2, 1), (2, 2), (1, 3)], (1, 1), (1, 2)], (1, 2): [[(2, 1), (2, 2), (1, 3)], (1, 1), (1, 2)]}
        self.Cases=[(i+1,j+1) for i in range(N) for j in range(N)] #cases vides
        komi={2: 0.5, 3: 0.5, 4: 0.5, 5: 0.5, 6: 0.5, 7: 0.5, 8: 0.5, 9: 0.5, 10: 0.5, 11: 0.5, 12: 0.5, 13: 0.5, 14: 0.5, 15: 0.5, 16: 0.5, 17: 0.5, 18: 0.5, 19: 0.5} #valeur du komi selon la taille du goban (pour l'instant 0.5 quelle que soit la taile)
        self.Points=[0,komi[N]] #liste des points : [pts_noir,pts_blanc]

from random import* #importation

def coup_humain(var,humain) : ###structure du coup du joueur humain###
    test=1
    points_sup=[]
    for case in var.Cases :
        if est_valide(var,case,humain)[0]==True :
            test=0
    if test==1 : #il n'y a aucun coup possible
        ans='Passer'
        print('Pas de coup possible.')
        var.Cases=[]
    else :
        print(' ')
        print('Coup?') #on demande le coup voulu
        error_check=1
        while error_check!=0 : #on vérifie si le coup est possible
            coup_str=input()
            error_check=0
            Coups_comprehensibles=[str((i+1,j+1)).replace(' ','') for i in range(var.N) for j in range(var.N)]+['Passer']+['passer'] #coups compréhensibles
            if coup_str not in Coups_comprehensibles : #le coup est-il compris?
                error_check=1
                print('Coup non reconnu. Saisir le coup une nouvelle fois.')
            elif coup_str not in ('Passer','passer') : #le coup est compris et le joueur ne passe pas
                i=int(coup_str[1])
                j=int(coup_str[3])
                valide=est_valide(var,(i,j),humain) #fonction est_valide en bas (partie 1 du coup)
                if (i,j) not in var.Cases : #case déja occupée
                    error_check=1
                    print('Case déja occupée. Choisir une autre case.')
                elif valide[0]==False : #le coup n'est PAS valide (False)
                    error_check=1
                    print(valide[4])
        if coup_str in ('Passer','passer') : #le coup est valide et le joueur a passé
            ans='Passer'
            var.Cases=[] #la partie s'arrête
        else : #le coup est valide et le joueur n'a pas passé
            ans=(i,j)
            points_sup=jouer_coup(var,valide,ans,humain) #fonction jouer_coup en bas (partie 2 du coup)
    return(ans,points_sup)

def coup_IA_alea(var,IA) : ###structure du coup de l'IA (joue aléatoirement)###
    Cases_copy=[k for k in var.Cases] #copie pour tester les cases valides sans modifer var.Cases
    n=int(random()*len(Cases_copy)) #case aléatoire
    coup=Cases_copy[n]
    valide=est_valide(var,coup,IA) #fonction est_valide en bas (partie 1 du coup)
    points_sup=[]
    while valide[0]==False and len(Cases_copy)>=2 : #si la case n'est pas valide et s'il en reste, on en reprend une autre
        Cases_copy.remove(coup) #on enlève le coup non valide pour ne pas le reprendre
        n=int(random()*len(Cases_copy)) #et on en reprend un
        coup=Cases_copy[n]
        valide=est_valide(var,coup,IA)
    if valide[0]==False : #si aucun coup n'est valide
        ans='pas de coup possible.'
        var.Cases=[] #la partie s'arrête
    else : #si le coup est valide
        ans=coup
        points_sup=jouer_coup(var,valide,ans,IA) #fonction jouer_coup en bas (partie 2 du coup)
    return(ans,points_sup)

def coup_IA_v1(var,IA) : ###structure du coup de l'IA, profondeur=1 pour l'instant###
    D=marshal.load(open('train_v1_'+str(var.N),'rb')) #on récupère les tests qu'on a déja faits
    meilleur_coup='' #meilleur coup retenu
    value=-1 #"valeur" de ce coup (% de victoire estimé après ce coup)
    points_sup=[]
    Cases_valides=[]
    for k in range(len(var.Cases)) :
        coup=var.Cases[k]
        valide=est_valide(var,coup,IA) #fonction est_valide en bas (partie 1 du coup)
        if valide[0]==True : #si le coup est valide, on prend sa "value"
            Cases_valides.append(coup)
            if indice(var.P,IA) in D :
                (n_win,n_tot)=D[indice(var.P,IA)]
                value_coup=n_win/n_tot
                if value_coup>value :
                    value=value_coup
                    meilleur_coup=coup
    if Cases_valides!=[] and meilleur_coup=='' : #s'il n'y a pas eu de tests pour cette position
        n=int(random()*len(Cases_valides)) #case aléatoire
        meilleur_coup=Cases_valides[n]
    if Cases_valides==[] : #si aucun coup n'est valide
        ans='pas de coup possible.'
        var.Cases=[] #la partie s'arrête
    else : #s'il y a un coup valide
        valide_meilleur=est_valide(var,meilleur_coup,IA)
        ans=meilleur_coup
        points_sup=jouer_coup(var,valide_meilleur,ans,IA) #fonction jouer_coup en bas (partie 2 du coup)
    return(ans,points_sup)

def coup_IA_v1_train(var,IA,n_sim) : ###structure du coup de l'IA###
    meilleur_coup='' #meilleur coup retenu
    value=-1 #"valeur" de ce coup (% de victoire estimé après ce coup)
    points_sup=[]
    D_coup={}
    for k in range(len(var.Cases)) :
        coup=var.Cases[k]
        valide=est_valide(var,coup,IA) #fonction est_valide en bas (partie 1 du coup)
        if valide[0]==True : #si le coup est valide, on cherche sa "value"
            c=0
            var_copy=copy.deepcopy(var)
            points_sup=jouer_coup(var_copy,valide,coup,IA)  #fonction jouer_coup en bas (partie 2 du coup)
            while points_sup!=[] : #on lui ajoute ses points si il en a gagné
                points=points_sup[0]
                var_copy.Points[IA-1]=var_copy.Points[IA-1]+points
                points_sup.remove(points)
            for l in range(n_sim) :
                var_2=copy.deepcopy(var_copy)
                if partie_alea(var_2,3-IA)==IA :
                    c=c+1
            D_coup[indice(var_copy.P,3-IA)]=n_sim-c #on sauvegarde les tests
            if c>value : #si le coup est meilleur que celui qu'on avait retenu :
                meilleur_coup=coup #il devient le meilleur coup
                value=c
    if meilleur_coup=='' : #si aucun coup n'est valide
        ans='pas de coup possible.'
        var.Cases=[] #la partie s'arrête
    else : #s'il y a un coup valide
        valide_meilleur=est_valide(var,meilleur_coup,IA)
        ans=meilleur_coup
        points_sup=jouer_coup(var,valide_meilleur,ans,IA) #fonction jouer_coup en bas (partie 2 du coup)
    return(ans,points_sup,D_coup)

def est_valide(var,coup,joueur) : ###le coup est-il valide? on ne vérifie que les conditions pour l'IA. Les autres du joueur (coup reconnu? et case occupée?) sont vérifiées au début de coup_joueur###
    ans=True
    i=int(coup[0])
    j=int(coup[1])
    Adj_joueur=[] #cases adjacentes qui appartiennent au joueur qui joue
    Adj_ennemi=[] #cases adjacentes qui appartiennent au joueur opposé
    Adj_autres=[] #cases adjacentes vides
    error=''
    if i!=1 : #on construit ces 3 listes
        if var.P[i-2][j-1]==joueur :
            Adj_joueur.append((i-1,j))
        elif var.P[i-2][j-1]==3-joueur :
            Adj_ennemi.append((i-1,j))
        else :
            Adj_autres.append((i-1,j))
    if i!=var.N : #de même
        if var.P[i][j-1]==joueur :
            Adj_joueur.append((i+1,j))
        elif var.P[i][j-1]==3-joueur :
            Adj_ennemi.append((i+1,j))
        else :
            Adj_autres.append((i+1,j))
    if j!=1 : #de même
        if var.P[i-1][j-2]==joueur :
            Adj_joueur.append((i,j-1))
        elif var.P[i-1][j-2]==3-joueur :
            Adj_ennemi.append((i,j-1))
        else :
            Adj_autres.append((i,j-1))
    if j!=var.N : #de même
        if var.P[i-1][j]==joueur :
            Adj_joueur.append((i,j+1))
        elif var.P[i-1][j]==3-joueur :
            Adj_ennemi.append((i,j+1))
        else :
            Adj_autres.append((i,j+1))
    test=1
    for case in Adj_ennemi :
        if len(var.Chaines[case][0])==1 :
            test=0 #test=0 si ce coup capture au moins une chaîne, dans ce cas pas de suicide
    if test==1 and len(Adj_autres)==0 : #sinon :
        for case in Adj_joueur :
            if len(var.Chaines[case][0])>1 :
                test=0 #test=0 si la case est liée à une chaîne alliée d'au moins 2 libertés
        if test==1 : #si non..
            ans=False
            error='Suicide. Choisir une autre case.' #..c'est un suicide
    if ans==True : #s'il n'y a pas de suicide
        P_save=[[var.P[a][b] for b in range(var.N)] for a in range(var.N)] #pour ne pas modifier P
        P_save[i-1][j-1]=joueur
        for case in Adj_ennemi :
            i2=case[0]
            j2=case[1]
            if len(var.Chaines[case][0])==1 and P_save[i2-1][j2-1]==3-joueur :
                for case_chaine in var.Chaines[case][1:] :
                    i3=case_chaine[0]
                    j3=case_chaine[1]
                    P_save[i3-1][j3-1]=0
        if P_save in var.Pos : #la position a-t-elle déja été atteinte?
            ans=False
            error='Position déja atteinte (ko)' #si oui, non valide (règle du ko)
    return(ans,Adj_joueur,Adj_ennemi,Adj_autres,error) #on renvoie les valeurs dont on a besoin dans les coups du joueur et de l'IA

def jouer_coup(var,valide,ans,joueur) : ###le coup est joué et les variables sont modifées (effet de bord)###
    points_sup=[]
    Adj_joueur=valide[1] #comme avant
    Adj_ennemi=valide[2] #comme avant
    Adj_autres=valide[3] #comme avant
    var.Cases.remove(ans) #ans n'est plus vide
    var.P[ans[0]-1][ans[1]-1]=joueur #P change
    var.Chaines[ans]=[[k for k in Adj_autres],ans]
    save=[k for k in Adj_ennemi]
    for case in save :
        if len(var.Chaines[case][0])==1 and case in Adj_ennemi : #si la chaîne est capturée :
            for case_2 in save :
                if case_2 in var.Chaines[case][1:] :
                    Adj_ennemi.remove(case_2) #on adapte les listes
                    Adj_autres.append(case_2)
            longueur=len(var.Chaines[case][1:])
            points_sup.append(longueur) #on attribue les points
            save_2=[k for k in var.Chaines[case][1:]]
            for case_chaine in save_2 : #et on adapte Chaines (des cases deviennent libre donc il y a de nouvelles libertés)
                var.Chaines[case_chaine]=[[]]
                var.Cases.append(case_chaine)
                i2=case_chaine[0]
                j2=case_chaine[1]
                var.P[i2-1][j2-1]=0
                if i2!=1 and var.P[i2-2][j2-1]==joueur :
                    for case_chaine_2 in var.Chaines[(i2-1,j2)][1:] :
                        var.Chaines[case_chaine_2][0].append(case_chaine)
                if i2!=var.N and var.P[i2][j2-1]==joueur and case_chaine not in var.Chaines[(i2+1,j2)][0] :
                    for case_chaine_2 in var.Chaines[(i2+1,j2)][1:] :
                        var.Chaines[case_chaine_2][0].append(case_chaine)
                if j2!=1 and var.P[i2-1][j2-2]==joueur and case_chaine not in var.Chaines[(i2,j2-1)][0] :
                    for case_chaine_2 in var.Chaines[(i2,j2-1)][1:] :
                        var.Chaines[case_chaine_2][0].append(case_chaine)
                if j2!=var.N and var.P[i2-1][j2]==joueur and case_chaine not in var.Chaines[(i2,j2+1)][0] :
                    for case_chaine_2 in var.Chaines[(i2,j2+1)][1:] :
                        var.Chaines[case_chaine_2][0].append(case_chaine)
    var.Pos.append(copy.deepcopy(var.P)) #P devient une position atteinte (deepcopy obligatoire ici)
    for case in Adj_ennemi :
        if ans in var.Chaines[case][0] :
            for case_2 in var.Chaines[case][1:] :
                var.Chaines[case_2][0].remove(ans) #la case n'est plus une liberté des chaînes adjacentes
    for case in Adj_joueur :
        if case not in var.Chaines[ans][1:] : #on regroupe les deux chaînes en une seule
            for case_2 in var.Chaines[case][1:] :
                var.Chaines[case_2][0].remove(ans) #la case n'est plus une liberté de la chaîne 2
            for case_2 in var.Chaines[ans][0] :
                if case_2 not in var.Chaines[case][0] :
                    for case_chaine in var.Chaines[case][1:] :
                        var.Chaines[case_chaine][0].append(case_2) #on rajoute les libertés de la chaîne 1 à celles de la chaîne 2
            for case_2 in var.Chaines[case][0] :
                if case_2 not in var.Chaines[ans][0] :
                    for case_chaine in var.Chaines[ans][1:] :
                        var.Chaines[case_chaine][0].append(case_2) #on rajoute les libertés de la chaîne 2 à celles de la chaîne 1
            save_1=[k for k in var.Chaines[case][1:]] #besoin de sauvegardes ici pour ne pas modifier
            save_2=[k for k in var.Chaines[ans][1:]]
            for case_1 in save_1 :
                for case_2 in save_2 :
                    var.Chaines[case_1].append(case_2) #on rajoute les cases de la chaîne 1 à la chaîne 2
                    var.Chaines[case_2].append(case_1) #on rajoute les cases de la chaîne 2 à la chaîne 1
    return(points_sup) #et on rend les points gagnés, seule info dont on a besoin de cette fonction

def partie_alea(var,joueur) : ###simulation d'une partie entre IAs qui jouent aléatoirement###
    while var.Cases!=[] : #tant qu'il reste des cases vides
        coup_1=coup_IA_alea(var,joueur) #joueur joue
        points_sup=coup_1[1]
        while points_sup!=[] : #on lui rajoute ses points s'il en a gagné
            points=points_sup[0]
            var.Points[joueur-1]=var.Points[joueur-1]+points
            points_sup.remove(points)
        if len(var.Cases)>=1 : #s'il reste une case vide
            coup_2=coup_IA_alea(var,3-joueur) #l'autre joueur joue
            points_sup=coup_2[1]
            while points_sup!=[] : #on lui rajoute ses points
                points=points_sup[0]
                var.Points[2-joueur]=var.Points[2-joueur]+points #comprendre 2-joueur = (3-joueur)-1 où 3-joueur est l'autre joueur
                points_sup.remove(points)
    if var.Points[0]>var.Points[1] :
        return(1) #Noir gagne
    elif var.Points[1]>var.Points[0] :
        return(2) #Blanc gagne

def indice(P,joueur) : ###fonction pour faciliter l'écriture des indices pour les dictionnaires sauvegardés###
    return((tuple([tuple(P[i]) for i in range(len(P))]),joueur))
    
def train_v1(N,n_parties,n_sim,coups_avant_train) : ###pour simuler des parties aléatoires et sauvegarder les résultats localement###
    D=marshal.load(open('train_v1_'+str(N),'rb')) #on récupère les tests qu'on a déja faits s'il y en a pour ne pas les perdre
    for i in range(n_parties) :
        var=settings(N) #on réinitialise var pour la partie suivante
        c=0
        while var.Cases!=[] : ###déroulement de la partie###
            if c<coups_avant_train :
                coup_1=coup_IA_v1(var,1) #coup de Noir
            else :
                coup_1=coup_IA_v1_train(var,1,n_sim) #coup de Noir
            points_sup=coup_1[1]
            while points_sup!=[] : #on lui ajoute ses points si il en a gagné
                points=points_sup[0]
                var.Points[0]=var.Points[0]+points
                points_sup.remove(points)
            D_coup=coup_1[2]
            for indice in D_coup :
                if indice in D :
                    (n_win,n_tot)=D[indice]
                    n_win=n_win+D_coup[indice]
                    n_tot=n_tot+n_sim
                    D[indice]=(n_win,n_tot)
                else :
                    D[indice]=(D_coup[indice],n_sim)
            c=c+1
            if len(var.Cases)>=1 : #s'il reste une case vide pour Blanc
                if c<coups_avant_train :
                    coup_2=coup_IA_v1(var,2) #coup de Blanc
                else :
                    coup_2=coup_IA_v1_train(var,2,n_sim) #coup de Blanc
                points_sup=coup_2[1]
                while points_sup!=[] : #on lui ajoute ses points
                    points=points_sup[0]
                    var.Points[1]=var.Points[1]+points
                    points_sup.remove(points)
                D_coup=coup_2[2]
                for indice in D_coup :
                    if indice in D :
                        (n_win,n_tot)=D[indice]
                        n_win=n_win+D_coup[indice]
                        n_tot=n_tot+n_sim
                        D[indice]=(n_win,n_tot)
                    else :
                        D[indice]=(D_coup[indice],n_sim)
                c=c+1
    marshal.dump(D,open('train_v1_'+str(N),'wb')) #on sauvegarde les données
