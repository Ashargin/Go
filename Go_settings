import copy #pour les deepcopies
import marshal #pour les sauvegardes locales
class settings : ###création de la classe settings pour l'attribution des variables utiles pour l'IA. Les autres variables qui ne servent qu'au joueur, le côté du joueur et le handicap, sont saisies au début de Go_main.py###
    def __init__(self,N) :
        self.N=N #taille du goban
        P=[[0 for i in range(N)] for j in range(N)]
        self.P=P #matrice d'état du plateau : 0 pour vide, 1 pour noir, 2 pour blanc
        self.Pos=[copy.deepcopy(P)] #liste des positions P déja atteintes (pour la règle du ko)
        self.Chaines={} #les chaînes formées. Chaines est construite de cette manière (IMPORTANT) : c'est un dictionnaire qui à chaque case (i,j) du plateau associe [[libertés de la chaîne], case_1_de_la_chaîne, ..., dernière_case_de_la_chaîne]. Par exemple, pour une chaîne de 2 cases avec (1,1) et (1,2), Chaîne={(1, 1): [[(2, 1), (2, 2), (1, 3)], (1, 1), (1, 2)], (1, 2): [[(2, 1), (2, 2), (1, 3)], (1, 1), (1, 2)]}
        self.Cases=[(i+1,j+1) for i in range(N) for j in range(N)] #cases vides
        self.Komi={2: 1.5, 3: 8.5, 4: 2.5, 5: 24.5, 6: 4.5, 7: 9.5, 8: 7.5, 9: 7.5, 10: 7.5, 11: 7.5, 12: 7.5, 13: 7.5, 14: 7.5, 15: 7.5, 16: 7.5, 17: 7.5, 18: 7.5, 19: 7.5} #valeur du komi selon la taille du goban en area scoring

from random import* #importation

def coup_humain(var,humain) : ###structure du coup du joueur humain###
    test=1
    for case in var.Cases :
        if est_valide(var,case,humain)[0]==True :
            test=0
    if test==1 : #il n'y a aucun coup possible
        ans='Passer'
        print('Pas de coup possible.')
        var.Cases=[]
    else :
        print('Coup?') #on demande le coup voulu
        error_check=1
        while error_check!=0 : #on vérifie si le coup est possible
            coup_str=input()
            error_check=0
            Coups_comprehensibles=[str((i+1,j+1)).replace(' ','') for i in range(var.N) for j in range(var.N)]+['Passer']+['passer'] #coups compréhensibles
            if coup_str not in Coups_comprehensibles : #le coup est-il compris?
                error_check=1
                print('Coup non reconnu. Saisir le coup une nouvelle fois.')
            elif coup_str not in ('Passer','passer') : #le coup est compris et le joueur ne passe pas
                i=int(coup_str[1])
                j=int(coup_str[3])
                valide=est_valide(var,(i,j),humain) #fonction est_valide en bas (partie 1 du coup)
                if (i,j) not in var.Cases : #case déja occupée
                    error_check=1
                    print('Case déja occupée. Choisir une autre case.')
                elif valide[0]==False : #le coup n'est PAS valide (False)
                    error_check=1
                    print(valide[4])
        if coup_str in ('Passer','passer') : #le coup est valide et le joueur a passé
            ans='Passer'
            var.Cases=[] #la partie s'arrête
        else : #le coup est valide et le joueur n'a pas passé
            ans=(i,j)
            jouer_coup(var,valide,ans,humain) #fonction jouer_coup en bas (partie 2 du coup)
    return(ans)

def coup_IA_alea(var,IA) : ###structure du coup de l'IA (joue aléatoirement)###
    Cases_copy=[k for k in var.Cases] #copie pour tester les cases valides sans modifer var.Cases
    n=int(random()*len(Cases_copy)) #case aléatoire
    coup=Cases_copy[n]
    valide=est_valide(var,coup,IA) #fonction est_valide en bas (partie 1 du coup)
    while valide[0]==False and len(Cases_copy)>=2 : #si la case n'est pas valide et s'il en reste, on en reprend une autre
        Cases_copy.remove(coup) #on enlève le coup non valide pour ne pas le reprendre
        n=int(random()*len(Cases_copy)) #et on en reprend un
        coup=Cases_copy[n]
        valide=est_valide(var,coup,IA)
    if valide[0]==False : #si aucun coup n'est valide
        ans='pas de coup possible.'
        var.Cases=[] #la partie s'arrête
    else : #si le coup est valide
        ans=coup
        jouer_coup(var,valide,ans,IA) #fonction jouer_coup en bas (partie 2 du coup)
    return(ans)

def coup_IA_v1(var,IA) : ###structure du coup de l'IA, profondeur=1 pour l'instant###
    D=marshal.load(open('train_v1_'+str(var.N),'rb')) #on récupère les tests qu'on a déja faits
    meilleur_coup='' #meilleur coup retenu
    value=-1 #"valeur" de ce coup (% de victoire estimé après ce coup)
    Cases_valides=[]
    for k in range(len(var.Cases)) :
        coup=var.Cases[k]
        valide=est_valide(var,coup,IA) #fonction est_valide en bas (partie 1 du coup)
        if valide[0]==True : #si le coup est valide, on prend sa "value"
            Cases_valides.append(coup)
            var_copy=copy.deepcopy(var)
            jouer_coup(var_copy,valide,coup,IA)  #fonction jouer_coup en bas (partie 2 du coup)
            if indice(var_copy.P,3-IA) in D :
                (n_win,n_tot)=D[indice(var_copy.P,3-IA)]
                value_coup=1-n_win/n_tot
                if value_coup>value :
                    value=value_coup
                    meilleur_coup=coup
    if Cases_valides!=[] and meilleur_coup=='' : #s'il n'y a pas eu de tests pour cette position
        n=int(random()*len(Cases_valides)) #case aléatoire
        meilleur_coup=Cases_valides[n]
    if Cases_valides==[] : #si aucun coup n'est valide
        ans='pas de coup possible.'
        var.Cases=[] #la partie s'arrête
    else : #s'il y a un coup valide
        valide_meilleur=est_valide(var,meilleur_coup,IA)
        ans=meilleur_coup
        jouer_coup(var,valide_meilleur,ans,IA) #fonction jouer_coup en bas (partie 2 du coup)
    return(ans)

def coup_IA_v1_train(var,IA,n_sim) : ###structure du coup de l'IA###
    meilleur_coup='' #meilleur coup retenu
    value=-1 #"valeur" de ce coup (% de victoire estimé après ce coup)
    D_coup={}
    for k in range(len(var.Cases)) :
        coup=var.Cases[k]
        valide=est_valide(var,coup,IA) #fonction est_valide en bas (partie 1 du coup)
        if valide[0]==True : #si le coup est valide, on cherche sa "value"
            c=0
            var_copy=copy.deepcopy(var)
            jouer_coup(var_copy,valide,coup,IA)  #fonction jouer_coup en bas (partie 2 du coup)
            for l in range(n_sim) :
                var_2=copy.deepcopy(var_copy)
                if partie_alea(var_2,3-IA)==IA :
                    c=c+1
            D_coup[indice(var_copy.P,3-IA)]=n_sim-c #on sauvegarde les tests
            if c>value : #si le coup est meilleur que celui qu'on avait retenu :
                meilleur_coup=coup #il devient le meilleur coup
                value=c
    if meilleur_coup=='' : #si aucun coup n'est valide
        ans='pas de coup possible.'
        var.Cases=[] #la partie s'arrête
    else : #s'il y a un coup valide
        valide_meilleur=est_valide(var,meilleur_coup,IA)
        ans=meilleur_coup
        jouer_coup(var,valide_meilleur,ans,IA) #fonction jouer_coup en bas (partie 2 du coup)
    return(ans,D_coup)

def est_valide(var,coup,joueur) : ###le coup est-il valide? on ne vérifie que les conditions pour l'IA. Les autres du joueur (coup reconnu? et case occupée?) sont vérifiées au début de coup_joueur###
    ans=True
    i=int(coup[0])
    j=int(coup[1])
    Adj_joueur=[] #cases adjacentes qui appartiennent au joueur qui joue
    Adj_ennemi=[] #cases adjacentes qui appartiennent au joueur opposé
    Adj_vides=[] #cases adjacentes vides
    error=''
    if i!=1 : #on construit ces 3 listes
        if var.P[i-2][j-1]==joueur :
            Adj_joueur.append((i-1,j))
        elif var.P[i-2][j-1]==3-joueur :
            Adj_ennemi.append((i-1,j))
        else :
            Adj_vides.append((i-1,j))
    if i!=var.N : #de même
        if var.P[i][j-1]==joueur :
            Adj_joueur.append((i+1,j))
        elif var.P[i][j-1]==3-joueur :
            Adj_ennemi.append((i+1,j))
        else :
            Adj_vides.append((i+1,j))
    if j!=1 : #de même
        if var.P[i-1][j-2]==joueur :
            Adj_joueur.append((i,j-1))
        elif var.P[i-1][j-2]==3-joueur :
            Adj_ennemi.append((i,j-1))
        else :
            Adj_vides.append((i,j-1))
    if j!=var.N : #de même
        if var.P[i-1][j]==joueur :
            Adj_joueur.append((i,j+1))
        elif var.P[i-1][j]==3-joueur :
            Adj_ennemi.append((i,j+1))
        else :
            Adj_vides.append((i,j+1))
    test=1
    for case in Adj_ennemi :
        if len(var.Chaines[case][0])==1 :
            test=0 #test=0 si ce coup capture au moins une chaîne, dans ce cas pas de suicide
    if test==1 and len(Adj_vides)==0 : #sinon :
        for case in Adj_joueur :
            if len(var.Chaines[case][0])>1 :
                test=0 #test=0 si la case est liée à une chaîne alliée d'au moins 2 libertés
        if test==1 : #si non..
            ans=False
            error='Suicide. Choisir une autre case.' #..c'est un suicide
    if ans==True : #s'il n'y a pas de suicide
        P_save=[[var.P[a][b] for b in range(var.N)] for a in range(var.N)] #pour ne pas modifier P
        P_save[i-1][j-1]=joueur
        for case in Adj_ennemi :
            i2=case[0]
            j2=case[1]
            if len(var.Chaines[case][0])==1 and P_save[i2-1][j2-1]==3-joueur :
                for case_chaine in var.Chaines[case][1:] :
                    i3=case_chaine[0]
                    j3=case_chaine[1]
                    P_save[i3-1][j3-1]=0
        if P_save in var.Pos : #la position a-t-elle déja été atteinte?
            ans=False
            if var.Pos[len(var.Pos)-2]==P_save :
                error='Position déja atteinte (ko)' #si oui, non valide (règle du ko)
            else :
                error='Position déja atteinte (superko)' #(ou du superko)
    return(ans,Adj_joueur,Adj_ennemi,Adj_vides,error) #on renvoie les valeurs dont on a besoin dans les coups du joueur et de l'IA

def jouer_coup(var,valide,ans,joueur) : ###le coup est joué et les variables sont modifées (effet de bord)###
    Adj_joueur=valide[1] #comme avant
    Adj_ennemi=valide[2] #comme avant
    Adj_vides=valide[3] #comme avant
    var.Cases.remove(ans) #ans n'est plus vide
    var.P[ans[0]-1][ans[1]-1]=joueur #P change
    var.Chaines[ans]=[[k for k in Adj_vides],ans]
    save=[k for k in Adj_ennemi]
    for case in save :
        if len(var.Chaines[case][0])==1 and case in Adj_ennemi : #si la chaîne est capturée :
            for case_2 in save :
                if case_2 in var.Chaines[case][1:] :
                    Adj_ennemi.remove(case_2) #on adapte les listes
                    Adj_vides.append(case_2)
            save_2=[k for k in var.Chaines[case][1:]]
            for case_chaine in save_2 : #et on adapte Chaines (des cases deviennent libre donc il y a de nouvelles libertés)
                var.Chaines[case_chaine]=[[]]
                var.Cases.append(case_chaine)
                i2=case_chaine[0]
                j2=case_chaine[1]
                var.P[i2-1][j2-1]=0
                if i2!=1 and var.P[i2-2][j2-1]==joueur :
                    for case_chaine_2 in var.Chaines[(i2-1,j2)][1:] :
                        var.Chaines[case_chaine_2][0].append(case_chaine)
                if i2!=var.N and var.P[i2][j2-1]==joueur and case_chaine not in var.Chaines[(i2+1,j2)][0] :
                    for case_chaine_2 in var.Chaines[(i2+1,j2)][1:] :
                        var.Chaines[case_chaine_2][0].append(case_chaine)
                if j2!=1 and var.P[i2-1][j2-2]==joueur and case_chaine not in var.Chaines[(i2,j2-1)][0] :
                    for case_chaine_2 in var.Chaines[(i2,j2-1)][1:] :
                        var.Chaines[case_chaine_2][0].append(case_chaine)
                if j2!=var.N and var.P[i2-1][j2]==joueur and case_chaine not in var.Chaines[(i2,j2+1)][0] :
                    for case_chaine_2 in var.Chaines[(i2,j2+1)][1:] :
                        var.Chaines[case_chaine_2][0].append(case_chaine)
    var.Pos.append(copy.deepcopy(var.P)) #P devient une position atteinte (deepcopy obligatoire ici)
    for case in Adj_ennemi :
        if ans in var.Chaines[case][0] :
            for case_2 in var.Chaines[case][1:] :
                var.Chaines[case_2][0].remove(ans) #la case n'est plus une liberté des chaînes adjacentes
    for case in Adj_joueur :
        if case not in var.Chaines[ans][1:] : #on regroupe les deux chaînes en une seule
            for case_2 in var.Chaines[case][1:] :
                var.Chaines[case_2][0].remove(ans) #la case n'est plus une liberté de la chaîne 2
            for case_2 in var.Chaines[ans][0] :
                if case_2 not in var.Chaines[case][0] :
                    for case_chaine in var.Chaines[case][1:] :
                        var.Chaines[case_chaine][0].append(case_2) #on rajoute les libertés de la chaîne 1 à celles de la chaîne 2
            for case_2 in var.Chaines[case][0] :
                if case_2 not in var.Chaines[ans][0] :
                    for case_chaine in var.Chaines[ans][1:] :
                        var.Chaines[case_chaine][0].append(case_2) #on rajoute les libertés de la chaîne 2 à celles de la chaîne 1
            save_1=[k for k in var.Chaines[case][1:]] #besoin de sauvegardes ici pour ne pas modifier
            save_2=[k for k in var.Chaines[ans][1:]]
            for case_1 in save_1 :
                for case_2 in save_2 :
                    var.Chaines[case_1].append(case_2) #on rajoute les cases de la chaîne 1 à la chaîne 2
                    var.Chaines[case_2].append(case_1) #on rajoute les cases de la chaîne 2 à la chaîne 1

def partie_alea(var,joueur) : ###simulation d'une partie entre IAs qui jouent aléatoirement###
    while var.Cases!=[] : #tant qu'il reste des cases vides
        coup_IA_alea(var,joueur) #joueur joue
        if len(var.Cases)>=1 : #s'il reste une case vide
            coup_IA_alea(var,3-joueur) #l'autre joueur joue
    Area=area(var)
    Score=[Area[0],Area[1]+var.Komi[var.N]]
    if Score[0]>Score[1] :
        return(1)
    elif Score[0]<Score[1] :
        return(2)

def indice(P,joueur) : ###fonction pour faciliter l'écriture des indices pour les dictionnaires sauvegardés###
    return((tuple([tuple(P[i]) for i in range(len(P))]),joueur))
    
def train_v1(N,n_parties,n_sim,coups_avant_train) : ###pour simuler des parties aléatoires et sauvegarder les résultats localement###
    D=marshal.load(open('train_v1_'+str(N),'rb')) #on récupère les tests qu'on a déja faits s'il y en a pour ne pas les perdre
    for i in range(n_parties) :
        var=settings(N) #on réinitialise var pour la partie suivante
        c=0
        while var.Cases!=[] : ###déroulement de la partie###
            if c<coups_avant_train :
                coup_IA_v1(var,1) #coup de Noir
                D_coup={}
            else :
                coup_1=coup_IA_v1_train(var,1,n_sim) #coup de Noir
                D_coup=coup_1[1]
            for indice in D_coup :
                if indice in D :
                    (n_win,n_tot)=D[indice]
                    n_win=n_win+D_coup[indice]
                    n_tot=n_tot+n_sim
                    D[indice]=(n_win,n_tot)
                else :
                    D[indice]=(D_coup[indice],n_sim)
            c=c+1
            if len(var.Cases)>=1 : #s'il reste une case vide pour Blanc
                if c<coups_avant_train :
                    coup_IA_v1(var,2) #coup de Blanc
                    D_coup={}
                else :
                    coup_2=coup_IA_v1_train(var,2,n_sim) #coup de Blanc
                    D_coup=coup_2[1]
                for indice in D_coup :
                    if indice in D :
                        (n_win,n_tot)=D[indice]
                        n_win=n_win+D_coup[indice]
                        n_tot=n_tot+n_sim
                        D[indice]=(n_win,n_tot)
                    else :
                        D[indice]=(D_coup[indice],n_sim)
                c=c+1
    marshal.dump(D,open('train_v1_'+str(N),'wb')) #on sauvegarde les données

def area(var) : ###fonction pour compter les points (en area scoring)###
    area_noir=0
    area_blanc=0
    territory=[] #on construit la liste des chaînes de cases vides de la gauche vers la droite et du haut vers le bas
    for i in range(1,var.N+1) :
        for j in range(1,var.N+1) :
            val=var.P[i-1][j-1]
            if val==1 : #c'est une case noire
                area_noir=area_noir+1
            elif val==2 : #c'est une case blanche
                area_blanc=area_blanc+1
            else : #c'est une case vide
                c_haut=0 #indicateurs
                c_gauche=0
                if i!=1 :
                    if var.P[i-2][j-1]==0 :
                        c_haut=1 #si la case de gauche est vide
                if j!=1 :
                    if var.P[i-1][j-2]==0 :
                        c_gauche=1 #si la case du haut est vide
                if c_haut==0 and c_gauche==0 :
                    territory.append([(i,j)]) #création d'une nouvelle chaîne
                elif c_haut==1 and c_gauche==0 :
                    territory[indice_chaine(territory,(i-1,j))].append((i,j)) #on lie la case à la chaîne du haut
                elif c_haut==0 and c_gauche==1 :
                    territory[indice_chaine(territory,(i,j-1))].append((i,j)) #on lie la case à la chaîne de gauche
                else : #les cases du haut et de gauche sont vides
                    k1=indice_chaine(territory,(i-1,j))
                    k2=indice_chaine(territory,(i,j-1))
                    if k1==k2 :#les cases du haut et de gauche sont dans le même chaîne
                        territory[k1].append((i,j))
                    else :
                        for case in territory[k2] :
                            territory[k1].append(case)
                        territory.remove(territory[k2])
                        territory[k1].append((i,j))
    for chaine in territory :
        Cases_adj=[]
        for case in chaine :
            i=case[0]
            j=case[1]
            if i!=1 :
                if var.P[i-2][j-1]!=0 :
                    Cases_adj.append(var.P[i-2][j-1])
            if i!=var.N :
                if var.P[i][j-1]!=0 :
                    Cases_adj.append(var.P[i][j-1])
            if j!=1 :
                if var.P[i-1][j-2]!=0 :
                    Cases_adj.append(var.P[i-1][j-2])
            if j!=var.N :
                if var.P[i-1][j]!=0 :
                    Cases_adj.append(var.P[i-1][j])
        joueur=Cases_adj[0]
        test=joueur
        k=1
        while test==joueur and k<len(Cases_adj) :
            if Cases_adj[k]!=joueur :
                test=0
            k=k+1
        if test==1 :
            area_noir=area_noir+len(chaine)
        elif test==2 :
            area_blanc=area_blanc+len(chaine)
    return(area_noir,area_blanc)

def indice_chaine(territory,case) : ###fonction pour trouver de quelle chaîne de cases vides fait partie la case###
    ans=-1
    k=0
    while ans==-1 :
        if case in territory[k] :
            ans=k
        k=k+1
    return(ans)
